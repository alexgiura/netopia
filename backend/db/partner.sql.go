// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: partner.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getPartners = `-- name: GetPartners :many
select
    id,
    code,
    name,
    type,
    vat_number,
    registration_number,
    personal_number,
    is_active
from core.partners
`

type GetPartnersRow struct {
	ID                 uuid.UUID
	Code               sql.NullString
	Name               string
	Type               string
	VatNumber          sql.NullString
	RegistrationNumber sql.NullString
	PersonalNumber     sql.NullString
	IsActive           bool
}

func (q *Queries) GetPartners(ctx context.Context) ([]GetPartnersRow, error) {
	rows, err := q.db.Query(ctx, getPartners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartnersRow
	for rows.Next() {
		var i GetPartnersRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Type,
			&i.VatNumber,
			&i.RegistrationNumber,
			&i.PersonalNumber,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPartnersByDocumentIds = `-- name: GetPartnersByDocumentIds :many
SELECT
    d.h_id,
    id,
    code,
    name,
    type,
    vat_number,
    registration_number,
    personal_number,
    is_active
FROM
    core.partners p
        JOIN
    core.document_header d ON p.id = d.partner_id
WHERE
        d.h_id = ANY($1::uuid[])
`

type GetPartnersByDocumentIdsRow struct {
	HID                uuid.UUID
	ID                 uuid.UUID
	Code               sql.NullString
	Name               string
	Type               string
	VatNumber          sql.NullString
	RegistrationNumber sql.NullString
	PersonalNumber     sql.NullString
	IsActive           bool
}

func (q *Queries) GetPartnersByDocumentIds(ctx context.Context, dollar_1 []uuid.UUID) ([]GetPartnersByDocumentIdsRow, error) {
	rows, err := q.db.Query(ctx, getPartnersByDocumentIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartnersByDocumentIdsRow
	for rows.Next() {
		var i GetPartnersByDocumentIdsRow
		if err := rows.Scan(
			&i.HID,
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Type,
			&i.VatNumber,
			&i.RegistrationNumber,
			&i.PersonalNumber,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPartner = `-- name: InsertPartner :one

Insert into core.partners (code,name,type,vat_number,registration_number,personal_number)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id
`

type InsertPartnerParams struct {
	Code               sql.NullString
	Name               string
	Type               string
	VatNumber          sql.NullString
	RegistrationNumber sql.NullString
	PersonalNumber     sql.NullString
}

// where  (code like ('%' || sqlc.arg(code) || '%') OR code IS NULL) and name like '%' || sqlc.arg(name) || '%' and type like '%' || sqlc.arg(type)|| '%' and tax_id like '%' || sqlc.arg(tax_id)|| '%';
func (q *Queries) InsertPartner(ctx context.Context, arg InsertPartnerParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertPartner,
		arg.Code,
		arg.Name,
		arg.Type,
		arg.VatNumber,
		arg.RegistrationNumber,
		arg.PersonalNumber,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updatePartner = `-- name: UpdatePartner :exec
Update core.partners
Set code=$2,
    name=$3,
    is_active=$4,
    type=$5,
    vat_number=$6,
    registration_number=$7,
    personal_number=$8
where id=$1
`

type UpdatePartnerParams struct {
	ID                 uuid.UUID
	Code               sql.NullString
	Name               string
	IsActive           bool
	Type               string
	VatNumber          sql.NullString
	RegistrationNumber sql.NullString
	PersonalNumber     sql.NullString
}

func (q *Queries) UpdatePartner(ctx context.Context, arg UpdatePartnerParams) error {
	_, err := q.db.Exec(ctx, updatePartner,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.IsActive,
		arg.Type,
		arg.VatNumber,
		arg.RegistrationNumber,
		arg.PersonalNumber,
	)
	return err
}
