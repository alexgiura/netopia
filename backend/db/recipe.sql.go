// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: recipe.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const deleteRecipeItems = `-- name: DeleteRecipeItems :exec
delete from core.recipe_items
where recipe_id=$1
`

func (q *Queries) DeleteRecipeItems(ctx context.Context, recipeID int32) error {
	_, err := q.db.Exec(ctx, deleteRecipeItems, recipeID)
	return err
}

const getRecipeById = `-- name: GetRecipeById :one
SELECT
    id,
    name,
    is_active
from core.recipes
where id=$1
`

func (q *Queries) GetRecipeById(ctx context.Context, id int32) (CoreRecipe, error) {
	row := q.db.QueryRow(ctx, getRecipeById, id)
	var i CoreRecipe
	err := row.Scan(&i.ID, &i.Name, &i.IsActive)
	return i, err
}

const getRecipeByItemId = `-- name: GetRecipeByItemId :many
SELECT
    r.id,
    r.name,
    r.is_active
from core.recipes r
inner JOIN core.items i ON r.name = i.name
WHERE r.is_active=true and i.id = $1
`

func (q *Queries) GetRecipeByItemId(ctx context.Context, id uuid.UUID) ([]CoreRecipe, error) {
	rows, err := q.db.Query(ctx, getRecipeByItemId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreRecipe
	for rows.Next() {
		var i CoreRecipe
		if err := rows.Scan(&i.ID, &i.Name, &i.IsActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeItemsByDocumentIds = `-- name: GetRecipeItemsByDocumentIds :many
SELECT
    ri.d_id as d_id,
    recipe_id as recipe_id,
    ri.item_id as item_id,
    i.code as item_code,
    i.name as item_name,
    quantity,
    um.id as um_id,
    um.name as um_name,
    um.code AS um_code,
    vat.id as vat_id,
    vat.name as vat_name,
    vat.percent as vat_percent,
    vat.exemption_reason AS vat_exemption_reason,
    vat.exemption_reason_code AS vat_exemption_reason_code,
    ri.production_item_type as item_type_pn
from core.recipe_items ri
         inner join core.items i
                    on i.id=ri.item_id
         inner join core.item_um um
                    on um.id=i.id_um
         inner join core.item_vat vat
                    on vat.id=i.id_vat

WHERE
        recipe_id = ANY($1::int[])
`

type GetRecipeItemsByDocumentIdsRow struct {
	DID                    uuid.UUID
	RecipeID               int32
	ItemID                 uuid.UUID
	ItemCode               sql.NullString
	ItemName               string
	Quantity               float64
	UmID                   int32
	UmName                 string
	UmCode                 string
	VatID                  int32
	VatName                string
	VatPercent             float64
	VatExemptionReason     sql.NullString
	VatExemptionReasonCode sql.NullString
	ItemTypePn             string
}

func (q *Queries) GetRecipeItemsByDocumentIds(ctx context.Context, dollar_1 []int32) ([]GetRecipeItemsByDocumentIdsRow, error) {
	rows, err := q.db.Query(ctx, getRecipeItemsByDocumentIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecipeItemsByDocumentIdsRow
	for rows.Next() {
		var i GetRecipeItemsByDocumentIdsRow
		if err := rows.Scan(
			&i.DID,
			&i.RecipeID,
			&i.ItemID,
			&i.ItemCode,
			&i.ItemName,
			&i.Quantity,
			&i.UmID,
			&i.UmName,
			&i.UmCode,
			&i.VatID,
			&i.VatName,
			&i.VatPercent,
			&i.VatExemptionReason,
			&i.VatExemptionReasonCode,
			&i.ItemTypePn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeItemsById = `-- name: GetRecipeItemsById :many
select
    ri.item_id as item_id,
    i.code as item_code,
    i.name as item_name,
    quantity,
    um.id as um_id,
    um.name as um_name,
    um.code AS um_code,
    ri.production_item_type as item_type_pn

from core.recipe_items ri
         inner join core.items i
                    on i.id=ri.item_id
         inner join core.item_um um
                    on um.id=i.id_um
where recipe_id=$1
`

type GetRecipeItemsByIdRow struct {
	ItemID     uuid.UUID
	ItemCode   sql.NullString
	ItemName   string
	Quantity   float64
	UmID       int32
	UmName     string
	UmCode     string
	ItemTypePn string
}

func (q *Queries) GetRecipeItemsById(ctx context.Context, recipeID int32) ([]GetRecipeItemsByIdRow, error) {
	rows, err := q.db.Query(ctx, getRecipeItemsById, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecipeItemsByIdRow
	for rows.Next() {
		var i GetRecipeItemsByIdRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemCode,
			&i.ItemName,
			&i.Quantity,
			&i.UmID,
			&i.UmName,
			&i.UmCode,
			&i.ItemTypePn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipes = `-- name: GetRecipes :many
SELECT
    id,
    name,
    is_active
from core.recipes
`

func (q *Queries) GetRecipes(ctx context.Context) ([]CoreRecipe, error) {
	rows, err := q.db.Query(ctx, getRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreRecipe
	for rows.Next() {
		var i CoreRecipe
		if err := rows.Scan(&i.ID, &i.Name, &i.IsActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveRecipe = `-- name: SaveRecipe :one
insert into core.recipes(name, is_active) VALUES ($1,$2)
    RETURNING id
`

type SaveRecipeParams struct {
	Name     string
	IsActive bool
}

func (q *Queries) SaveRecipe(ctx context.Context, arg SaveRecipeParams) (int32, error) {
	row := q.db.QueryRow(ctx, saveRecipe, arg.Name, arg.IsActive)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const saveRecipeItems = `-- name: SaveRecipeItems :one
Insert into core.recipe_items(recipe_id, item_id, quantity, production_item_type)
VALUES  ($1,$2,$3,$4)
    RETURNING d_id
`

type SaveRecipeItemsParams struct {
	RecipeID           int32
	ItemID             uuid.UUID
	Quantity           float64
	ProductionItemType string
}

func (q *Queries) SaveRecipeItems(ctx context.Context, arg SaveRecipeItemsParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, saveRecipeItems,
		arg.RecipeID,
		arg.ItemID,
		arg.Quantity,
		arg.ProductionItemType,
	)
	var d_id uuid.UUID
	err := row.Scan(&d_id)
	return d_id, err
}

const updateRecipe = `-- name: UpdateRecipe :exec
update core.recipes
SET name=$2, is_active=$3
where id=$1
`

type UpdateRecipeParams struct {
	ID       int32
	Name     string
	IsActive bool
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe, arg.ID, arg.Name, arg.IsActive)
	return err
}
