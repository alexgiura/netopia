// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: item.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getItemCategoryByID = `-- name: GetItemCategoryByID :one
SELECT ic.name,
       ic.is_active,
       ic.generate_pn
FROM core.item_category ic
         INNER JOIN core.items i ON i.id_category = ic.id
WHERE ic.is_active = true AND i.id = $1
    LIMIT 1
`

type GetItemCategoryByIDRow struct {
	Name       string
	IsActive   bool
	GeneratePn bool
}

func (q *Queries) GetItemCategoryByID(ctx context.Context, id uuid.UUID) (GetItemCategoryByIDRow, error) {
	row := q.db.QueryRow(ctx, getItemCategoryByID, id)
	var i GetItemCategoryByIDRow
	err := row.Scan(&i.Name, &i.IsActive, &i.GeneratePn)
	return i, err
}

const getItemCategoryList = `-- name: GetItemCategoryList :many
select id,
       name,
       is_active,
       generate_pn
from core.item_category
`

func (q *Queries) GetItemCategoryList(ctx context.Context) ([]CoreItemCategory, error) {
	rows, err := q.db.Query(ctx, getItemCategoryList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreItemCategory
	for rows.Next() {
		var i CoreItemCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.GeneratePn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItems = `-- name: GetItems :many
select
    i.id as id,
    i.code as code,
    i.name as name,
    i.is_active,
    is_stock,
    um.id as um_id,
    um.name as um_name,
    um.code as um_code,
    um.is_active as um_is_active,
    vat.id as vat_id,
    vat.name as vat_name,
    vat.percent as vat_percent,
    vat.is_active as vat_is_active,
    i.id_category as category_id,
    c.name as category_name,
    c.is_active as category_is_active,
    c.generate_pn as category_generate_pn
from core.items i
         inner join core.item_um um
                    on um.id=i.id_um
         inner join core.item_vat vat
                    on vat.id=i.id_vat
         left join core.item_category c
                    on c.id=i.id_category
where ($1::integer[]) IS NULL OR cardinality($1::integer[]) = 0 OR  i.id_category = ANY($1::integer[])
`

type GetItemsRow struct {
	ID                 uuid.UUID
	Code               sql.NullString
	Name               string
	IsActive           bool
	IsStock            bool
	UmID               int32
	UmName             string
	UmCode             string
	UmIsActive         bool
	VatID              int32
	VatName            string
	VatPercent         float64
	VatIsActive        bool
	CategoryID         sql.NullInt32
	CategoryName       sql.NullString
	CategoryIsActive   sql.NullBool
	CategoryGeneratePn sql.NullBool
}

func (q *Queries) GetItems(ctx context.Context, category []int32) ([]GetItemsRow, error) {
	rows, err := q.db.Query(ctx, getItems, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsRow
	for rows.Next() {
		var i GetItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.IsActive,
			&i.IsStock,
			&i.UmID,
			&i.UmName,
			&i.UmCode,
			&i.UmIsActive,
			&i.VatID,
			&i.VatName,
			&i.VatPercent,
			&i.VatIsActive,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryIsActive,
			&i.CategoryGeneratePn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUmList = `-- name: GetUmList :many
select id,
       name,
       code,
       is_active
from core.item_um
`

func (q *Queries) GetUmList(ctx context.Context) ([]CoreItemUm, error) {
	rows, err := q.db.Query(ctx, getUmList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreItemUm
	for rows.Next() {
		var i CoreItemUm
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVatList = `-- name: GetVatList :many
select id,
       name,
       percent,
       exemption_reason,
       exemption_reason_code,
       is_active
from core.item_vat
`

func (q *Queries) GetVatList(ctx context.Context) ([]CoreItemVat, error) {
	rows, err := q.db.Query(ctx, getVatList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreItemVat
	for rows.Next() {
		var i CoreItemVat
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Percent,
			&i.ExemptionReason,
			&i.ExemptionReasonCode,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertItem = `-- name: InsertItem :one
Insert into core.items (code,name,id_um,id_vat,is_active,is_stock, id_category)
VALUES ($1,$2,$3,$4,$5,$6,$7)
    RETURNING id
`

type InsertItemParams struct {
	Code       sql.NullString
	Name       string
	IDUm       int32
	IDVat      int32
	IsActive   bool
	IsStock    bool
	IDCategory sql.NullInt32
}

func (q *Queries) InsertItem(ctx context.Context, arg InsertItemParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertItem,
		arg.Code,
		arg.Name,
		arg.IDUm,
		arg.IDVat,
		arg.IsActive,
		arg.IsStock,
		arg.IDCategory,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertItemCategory = `-- name: InsertItemCategory :one
Insert into core.item_category (name,is_active,generate_pn)
VALUES ($1,$2,$3)
    RETURNING id
`

type InsertItemCategoryParams struct {
	Name       string
	IsActive   bool
	GeneratePn bool
}

func (q *Queries) InsertItemCategory(ctx context.Context, arg InsertItemCategoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertItemCategory, arg.Name, arg.IsActive, arg.GeneratePn)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertUm = `-- name: InsertUm :one
Insert into core.item_um (name,code,is_active)
VALUES ($1,$2,$3)
    RETURNING id, name, code, is_active
`

type InsertUmParams struct {
	Name     string
	Code     string
	IsActive bool
}

func (q *Queries) InsertUm(ctx context.Context, arg InsertUmParams) (CoreItemUm, error) {
	row := q.db.QueryRow(ctx, insertUm, arg.Name, arg.Code, arg.IsActive)
	var i CoreItemUm
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.IsActive,
	)
	return i, err
}

const updateItem = `-- name: UpdateItem :exec
Update core.items
Set code=$2,
    name=$3,
    id_um=$4,
    id_vat=$5,
    is_active=$6,
    is_stock=$7,
    id_category=$8
where id=$1
`

type UpdateItemParams struct {
	ID         uuid.UUID
	Code       sql.NullString
	Name       string
	IDUm       int32
	IDVat      int32
	IsActive   bool
	IsStock    bool
	IDCategory sql.NullInt32
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.Exec(ctx, updateItem,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.IDUm,
		arg.IDVat,
		arg.IsActive,
		arg.IsStock,
		arg.IDCategory,
	)
	return err
}

const updateItemCategory = `-- name: UpdateItemCategory :exec
Update core.item_category
Set name=$2,
    is_active=$3,
    generate_pn=$4
where id=$1
`

type UpdateItemCategoryParams struct {
	ID         int32
	Name       string
	IsActive   bool
	GeneratePn bool
}

func (q *Queries) UpdateItemCategory(ctx context.Context, arg UpdateItemCategoryParams) error {
	_, err := q.db.Exec(ctx, updateItemCategory,
		arg.ID,
		arg.Name,
		arg.IsActive,
		arg.GeneratePn,
	)
	return err
}

const updateUm = `-- name: UpdateUm :one
Update core.item_um
Set name=$2,
    code=$3,
    is_active=$4
where id=$1
    RETURNING id, name, code, is_active
`

type UpdateUmParams struct {
	ID       int32
	Name     string
	Code     string
	IsActive bool
}

func (q *Queries) UpdateUm(ctx context.Context, arg UpdateUmParams) (CoreItemUm, error) {
	row := q.db.QueryRow(ctx, updateUm,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.IsActive,
	)
	var i CoreItemUm
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.IsActive,
	)
	return i, err
}
