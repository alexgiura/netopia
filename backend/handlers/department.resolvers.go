package handlers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/db"
	_err "backend/errors"
	"backend/graph/generated"
	"backend/graph/model"
	"backend/models"
	"backend/util"
	"context"
	"errors"
	"fmt"
	"github.com/graph-gophers/dataloader"
	"log"

	pgx "github.com/jackc/pgx/v4"
	"go.uber.org/zap"
)

// Parents is the resolver for the parents field.
func (r *departmentResolver) Parents(ctx context.Context, obj *models.Department) ([]*models.Department, error) {

	loaders, ok := ctx.Value("loaders").(*models.Loaders)
	if !ok {
		log.Print("\"message\": Unable to fetch loaders from context, \"error\": context value is not of type *models.Loaders")
		return nil, _err.Error(ctx, "ContextError", "InternalError")
	}

	resultFuture := loaders.DepartmentLoader.Load(ctx, dataloader.StringKey(*util.Int32ToString(int32(obj.ID))))
	result, err := resultFuture()
	if err != nil {
		log.Print("\"message\": Failed to load departmets using DepartmentLoader, \"error\": ", err.Error())
		return nil, _err.Error(ctx, "FailedToLoadDepartments", "DatabaseError")
	}

	departments, ok := result.([]*models.Department)
	if !ok {

		log.Print("\"message\": Unexpected type for Departments, \"error\": unexpected type ", fmt.Sprintf("%T", result))
		return nil, _err.Error(ctx, "UnexpectedType", "InternalError")
	}

	return departments, nil
}

// SaveDepartment is the resolver for the saveDepartment field.
func (r *mutationResolver) SaveDepartment(ctx context.Context, input model.DepartmentInput) (*models.Department, error) {
	if input.ID == nil {
		// Insert new Department
		newDepartment, err := r.DBProvider.InsertDepartment(ctx, db.InsertDepartmentParams{
			Name:      input.Name,
			Flags:     util.NullableInt32(&input.Flags),
			ParentIds: util.IntArrayToInt32Array(input.ParentsIds),
		})
		if err != nil {
			log.Printf("\"message\": \"Failed to execute DBProvider.InsertDepartment\", \"error\": \"%s\"", err.Error())
			return nil, _err.Error(ctx, "InsertFailed", "DatabaseError")
		}
		return &models.Department{
			ID:    int(newDepartment.ID),
			Name:  newDepartment.Name,
			Flags: int(newDepartment.Flags),
		}, nil
	} else {
		// Update existing Department
		updatedDepartment, err := r.DBProvider.UpdateDepartment(ctx, db.UpdateDepartmentParams{
			ID:        int32(*input.ID),
			Name:      util.ParamStr(&input.Name),
			Flags:     util.NullableInt32(&input.Flags),
			ParentIds: util.IntArrayToInt32Array(input.ParentsIds),
		})
		if err != nil {
			log.Printf("\"message\": \"Failed to execute DBProvider.UpdateDepartment\", \"error\": \"%s\"", err.Error())
			return nil, _err.Error(ctx, "UpdateFailed", "DatabaseError")
		}
		return &models.Department{
			ID:    int(updatedDepartment.ID),
			Name:  updatedDepartment.Name,
			Flags: int(updatedDepartment.Flags),
		}, nil
	}

	return nil, nil
}

// GetDepartments is the resolver for the getDepartments field.
func (r *queryResolver) GetDepartments(ctx context.Context) ([]*models.Department, error) {
	rows, err := r.DBProvider.GetDepartmentList(ctx)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		r.Logger.Error("failed to execute DBProvider.GetDepartmentList", zap.Error(err))
		return nil, _err.Error(ctx, "Failed to get departments", "DatabaseError")
	}

	departments := make([]*models.Department, 0)

	for _, row := range rows {

		department := &models.Department{

			ID: int(row.ID),

			Name:  row.Name,
			Flags: int(row.Flags),
		}

		departments = append(departments, department)

	}

	return departments, nil
}

// Department returns generated.DepartmentResolver implementation.
func (r *Resolver) Department() generated.DepartmentResolver { return &departmentResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type departmentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
