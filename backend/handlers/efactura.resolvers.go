package handlers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	_err "backend/errors"
	"backend/graph/model"
	"backend/util"
	"context"
	"github.com/printesoi/e-factura-go/oauth2"
	"log"
	"sync"
)

// GenerateEfacturaAuthorizationLink is the resolver for the generateEfacturaAuthorizationLink field.
func (r *mutationResolver) GenerateEfacturaAuthorizationLink(ctx context.Context) (*string, error) {
	uuid, err := r.DBProvider.GenerateAuthorization(ctx)
	if err != nil {
		log.Print("\"message\":GenerateAuthorization failed, "+"\"error\": ", err.Error())
		return nil, _err.Error(ctx, "InsertFailed", "DatabaseError")
	}

	oauth2Cfg, err := oauth2.MakeConfig(oauth2.ConfigCredentials(r.EfacturaSettings.ClientID, r.EfacturaSettings.ClientSecret),
		oauth2.ConfigRedirectURL(r.EfacturaSettings.CallbackURL))
	if err != nil {
		log.Print("\"message\":oauth2.MakeConfig failed, "+"\"error\": ", err.Error())
		return nil, _err.Error(ctx, "Failed to generate authorization URL", "InternalError")
	}

	authURL := oauth2Cfg.AuthCodeURL(uuid.String())
	return &authURL, nil
}

// UploadEfacturaDocument is the resolver for the uploadEfacturaDocument field.
func (r *mutationResolver) UploadEfacturaDocument(ctx context.Context, input model.GenerateEfacturaDocumentInput) (*string, error) {
	regenerate := false
	if input.Regenerate != nil {
		regenerate = *input.Regenerate
	}

	var wg sync.WaitGroup

	for _, hid := range input.HIDList {

		wg.Add(1) // Increment the WaitGroup counter

		go func(hid *string) {
			defer wg.Done() // Decrement the counter when the goroutine completes

			docID := util.StrToUUID(hid)
			efacturaDocID, _, err := r._EfacturaGenerateAndUpload(ctx, docID, regenerate)
			if err != nil {
				log.Printf("Error generating and uploading document for HID: %s, error: %s", *hid, err.Error())
				return
			}

			// Create the task message for RabbitMQ
			message := TaskMessage{
				Task:               "CheckEfacturaUploadState",
				EfacturaDocumentID: efacturaDocID.String(),
				CheckInterval:      1000,  // 1 second
				MaxWaitTime:        10000, // 10 seconds
			}

			// Send the message to RabbitMQ
			err2 := r.sendToRabbitMQ(ctx, message)
			if err2 != nil {
				log.Printf("Failed to send message to RabbitMQ for document %s, error: %s", efacturaDocID.String(), err2.Error())
				return // Log the error and continue
			}

		}(hid)
	}

	// Wait for all goroutines to finish
	wg.Wait()

	// Return a success message
	response := "success"
	return &response, nil
}

// CheckEfacturaUploadState is the resolver for the checkEfacturaUploadState field.
func (r *mutationResolver) CheckEfacturaUploadState(ctx context.Context, efacturaDocumentID string) (*string, error) {
	docID := util.StrToUUID(&efacturaDocumentID)
	status, err := r._EfacturaCheckUploadState(ctx, docID)
	if err != nil {
		return nil, err
	}
	return util.StringPtr(string(status)), nil
}
