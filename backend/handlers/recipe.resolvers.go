package handlers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	_err "backend/errors"
	"backend/graph/model"
	"context"
	"errors"
	"log"

	pgx "github.com/jackc/pgx/v4"
)

// SaveRecipe is the resolver for the saveRecipe field.
func (r *mutationResolver) SaveRecipe(ctx context.Context, input model.SaveRecipeInput) (*string, error) {
	if input.ID == nil {
		_, err := r._insertRecipe(ctx, input)
		if err != nil {

			return nil, err
		}
		response := "success"
		return &response, nil

	} else {
		_, err := r._updateRecipe(ctx, input)
		if err != nil {

			return nil, err
		}
		response := "success"
		return &response, nil
	}
}

// GetRecipes is the resolver for the getRecipes field.
func (r *queryResolver) GetRecipes(ctx context.Context) ([]*model.Recipe, error) {
	returnRecipes := make([]*model.Recipe, 0)
	if err := r.DBPool.BeginFunc(ctx, func(tx pgx.Tx) error {
		transaction := r.DBProvider.WithTx(tx)

		rows, err := transaction.GetRecipes(ctx)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return nil
			}
			return err
		}
		recipes := make([]*model.Recipe, 0)

		for _, row := range rows {
			documentItems, err := r._getRecipeItems(ctx, transaction, row.ID)
			if err != nil {
				return err
			}
			recipe := &model.Recipe{
				ID:            int(row.ID),
				Name:          row.Name,
				IsActive:      row.IsActive,
				DocumentItems: documentItems,
			}

			recipes = append(recipes, recipe)
		}

		returnRecipes = recipes
		return nil
	}); err != nil {

		log.Print("\"message\":Failed to save document, "+"\"error\": ", err.Error())
		return nil, _err.Error(ctx, "Failed to save document", "DatabaseError")
	}

	return returnRecipes, nil
}

// GetRecipeByID is the resolver for the getRecipeById field.
func (r *queryResolver) GetRecipeByID(ctx context.Context, recipeID int) (*model.Recipe, error) {
	returnRecipes := new(model.Recipe)
	if err := r.DBPool.BeginFunc(ctx, func(tx pgx.Tx) error {
		transaction := r.DBProvider.WithTx(tx)
		recipe, err := r._getRecipeById(ctx, transaction, int32(recipeID))
		if err != nil {
			return err
		}

		returnRecipes = recipe
		return nil
	}); err != nil {

		log.Print("\"message\":Failed to save document, "+"\"error\": ", err.Error())
		return nil, _err.Error(ctx, "Failed to save document", "DatabaseError")
	}

	return returnRecipes, nil
}
