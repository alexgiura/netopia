package handlers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	_err "backend/errors"
	"backend/graph/generated"
	"backend/graph/model"
	"backend/models"
	"backend/util"
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/graph-gophers/dataloader"
	pgx "github.com/jackc/pgx/v4"
)

// SaveRecipe is the resolver for the saveRecipe field.
func (r *mutationResolver) SaveRecipe(ctx context.Context, input model.SaveRecipeInput) (*models.Recipe, error) {
	if input.ID == nil {
		recipe, err := r._insertRecipe(ctx, input)
		if err != nil {

			return nil, err
		}

		return recipe, nil

	} else {
		recipe, err := r._updateRecipe(ctx, input)
		if err != nil {

			return nil, err
		}

		return recipe, nil
	}
}

// GetRecipes is the resolver for the getRecipes field.
func (r *queryResolver) GetRecipes(ctx context.Context) ([]*models.Recipe, error) {
	rows, err := r.DBProvider.GetRecipes(ctx)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		log.Print("\"message\":Failed to execute DBProvider.GetRecipes, "+"\"error\": ", err.Error())
		return nil, _err.Error(ctx, "Failed to get recipes", "DatabaseError")
	}
	recipes := make([]*models.Recipe, 0)

	for _, row := range rows {
		recipe := &models.Recipe{
			ID:       int(row.ID),
			Name:     row.Name,
			IsActive: row.IsActive,
		}

		recipes = append(recipes, recipe)
	}

	return recipes, nil
}

// GetRecipeByID is the resolver for the getRecipeById field.
func (r *queryResolver) GetRecipeByID(ctx context.Context, recipeID int) (*models.Recipe, error) {
	returnRecipes := new(models.Recipe)
	if err := r.DBPool.BeginFunc(ctx, func(tx pgx.Tx) error {
		transaction := r.DBProvider.WithTx(tx)
		recipe, err := r._getRecipeById(ctx, transaction, int32(recipeID))
		if err != nil {
			return err
		}

		returnRecipes = recipe
		return nil
	}); err != nil {

		log.Print("\"message\":Failed to save document, "+"\"error\": ", err.Error())
		return nil, _err.Error(ctx, "Failed to save document", "DatabaseError")
	}

	return returnRecipes, nil
}

// DocumentItems is the resolver for the document_items field.
func (r *recipeResolver) DocumentItems(ctx context.Context, obj *models.Recipe) ([]*models.DocumentItem, error) {
	loaders, ok := ctx.Value("loaders").(*models.Loaders)
	if !ok {
		log.Print("\"message\": Unable to fetch loaders from context, \"error\": context value is not of type *models.Loaders")
		return nil, _err.Error(ctx, "ContextError", "InternalError")
	}

	resultFuture := loaders.RecipeItemLoader.Load(ctx, dataloader.StringKey(*util.Int32ToString(int32(obj.ID))))
	result, err := resultFuture()
	if err != nil {
		log.Print("\"message\": Failed to load recipe items using DocumentItemLoader, \"error\": ", err.Error())
		return nil, _err.Error(ctx, "FailedToLoadDocumentItems", "DatabaseError")
	}

	documentItems, ok := result.([]*models.DocumentItem)
	if !ok {
		log.Print("\"message\": Unexpected type for DocumentItems, \"error\": unexpected type ", fmt.Sprintf("%T", result))
		return nil, _err.Error(ctx, "UnexpectedType", "InternalError")
	}

	return documentItems, nil
}

// Recipe returns generated.RecipeResolver implementation.
func (r *Resolver) Recipe() generated.RecipeResolver { return &recipeResolver{r} }

type recipeResolver struct{ *Resolver }
